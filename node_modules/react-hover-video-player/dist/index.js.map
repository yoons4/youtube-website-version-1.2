{"version":3,"file":"index.js","sources":["../node_modules/tslib/tslib.es6.js","../src/hooks/useSetAdditionalAttributesOnVideo.ts","../src/hooks/useFormatVideoSrc.ts","../src/hooks/useFormatVideoCaptions.ts","../src/hooks/useHoverTargetElement.ts","../src/hooks/useManageHoverEvents.ts","../src/utils/videoElementPlaybackStates.ts","../src/component/HoverVideoPlayer.styles.ts","../src/component/HoverVideoPlayer.tsx"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","import React, { useEffect } from 'react';\n\n/**\n * Hook handles manually setting some additional attributes on the video that\n * can't be set directly via attributes on the element.\n *\n * @param {React.RefObject<HTMLVideoElement>} videoRef - Ref to the video element\n * @param {bool} muted - Whether the video should be muted\n * @param {number} volume - The volume level that the video's audio should be set to\n * @param {bool} disableRemotePlayback - Whether we want to disable showing controls to cast the video\n * @param {bool} disablePictureInPicture - Whether we want to disable showing controls to play the video in picture-in-picture mode\n */\nexport default function useSetAdditionalAttributesOnVideo(\n  videoRef: React.RefObject<HTMLVideoElement>,\n  muted: boolean,\n  volume: number,\n  disableRemotePlayback: boolean,\n  disablePictureInPicture: boolean\n): void {\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    // Manually setting the `muted` attribute on the video element via an effect in order\n    // to avoid a know React issue with the `muted` prop not applying correctly on initial render\n    // https://github.com/facebook/react/issues/10389\n    videoElement.muted = muted;\n    // Set the video's volume to match the `volume` prop\n    // Note that this will have no effect if the `muted` prop is set to true\n    videoElement.volume = volume;\n  }, [videoRef, muted, volume]);\n\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    // React does not support directly setting disableRemotePlayback or disablePictureInPicture directly\n    // via the video element's props, so we have to manually set them in an effect\n    videoElement.disableRemotePlayback = disableRemotePlayback;\n    videoElement.disablePictureInPicture = disablePictureInPicture;\n  }, [videoRef, disablePictureInPicture, disableRemotePlayback]);\n}\n","import { useRef } from 'react';\nimport { VideoSource, VideoSrcProp } from '../HoverVideoPlayer.types';\n\n/**\n * @function  formatVideoSrc\n *\n * Hook takes the videoSrc prop and formats it as a standardized array of VideoSource objects which can be used to render\n * <source> elements for the video\n *\n * @param {VideoSrcProp}  videoSrc - Source(s) to format into VideoSource objects so they can be added to the video player.\n * @param {number}  playbackRangeStart - The earliest time in seconds that we should start loading the video from.\n *                                        This will be enforced by using a #t media fragment identifier to tell the browser to only\n *                                        load the video starting from this time.\n *                                        If not provided, we will load from the start of the video.\n * @param {number}  playbackRangeEnd - The maximum time in seconds that we should load the video to.\n *                                        This will be enforced by using a #t media fragment identifier to tell the browser to only\n *                                        load the video up to this time.\n *                                        If not provided, we will load to the end of the video.\n *\n * @returns {VideoSource[]} Array of formatted VideoSource objects which can be used to render <source> elements for the video\n */\nexport default function useFormatVideoSrc(\n  videoSrc: VideoSrcProp,\n  playbackRangeStart?: number,\n  playbackRangeEnd?: number\n): VideoSource[] {\n  const previousVideoSrc = useRef(null);\n  const previousFormattedVideoSources = useRef<VideoSource[]>(null);\n\n  // If videoSrc is shallowly equal with the previous videoSrc we can just return the previous formatted video sources\n  if (\n    previousVideoSrc.current !== null &&\n    videoSrc === previousVideoSrc.current\n  ) {\n    return previousFormattedVideoSources.current;\n  }\n\n  // Store the previous videoSrc so we can compare it on the next render\n  previousVideoSrc.current = videoSrc;\n\n  const formattedVideoSources = [];\n\n  if (videoSrc == null) {\n    // A videoSrc value is required in order to make the video player work\n    console.error(\n      \"Error: 'videoSrc' prop is required for HoverVideoPlayer component\"\n    );\n  } else {\n    // Make sure we can treat the videoSrc value as an array\n    const rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc];\n\n    // Parse our video source values into an array of VideoSource objects that can be used to render sources for the video\n    for (\n      let i = 0, numSources = rawVideoSources.length;\n      i < numSources;\n      i += 1\n    ) {\n      const source = rawVideoSources[i];\n\n      const hasPlaybackRangeStart = playbackRangeStart !== null;\n      const hasPlaybackRangeEnd = playbackRangeEnd !== null;\n\n      // Construct a media fragment identifier string to append to the video's URL to ensure\n      // we only load the portion of the video that we need for the provided playback range\n      // (see here for more details: https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery#specifying_playback_range)\n      const playbackRangeMediaFragmentIdentifier =\n        hasPlaybackRangeStart || hasPlaybackRangeEnd\n          ? // If we have a playback range defined, construct a #t media fragment identifier string\n            // This identifier follows the format `#t=[starttime][,endtime]` and will tell the browser to only load the video file\n            // within this defined time range.\n            // This helps save us from loading some unneeded data when we only need whatever is within the playback range!\n            `#t=${hasPlaybackRangeStart ? playbackRangeStart : ''}${\n              hasPlaybackRangeEnd ? `,${playbackRangeEnd}` : ''\n            }`\n          : '';\n\n      if (typeof source === 'string') {\n        // If the source is a string, it's an src URL so format it into a VideoSource object and add it to the array\n        formattedVideoSources.push({\n          src: `${source}${playbackRangeMediaFragmentIdentifier}`,\n        });\n      } else if (source && source.src) {\n        // If the source is an object with an src, just add it to the array\n        formattedVideoSources.push({\n          src: `${source.src}${playbackRangeMediaFragmentIdentifier}`,\n          type: source.type,\n        });\n      } else {\n        // Log an error if one of the videoSrc values is invalid\n        console.error(\n          \"Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':\",\n          source\n        );\n      }\n    }\n  }\n\n  // If our formatted video sources are deeply equal to the previous formatted sources\n  // based on a simple string comparison, return the previous formatted sources instead to maintain\n  // referential equality\n  if (\n    JSON.stringify(formattedVideoSources) ===\n    JSON.stringify(previousFormattedVideoSources.current)\n  ) {\n    return previousFormattedVideoSources.current;\n  }\n\n  // Store the final formatted video sources so we can return them on subsequent renders\n  // if the videoSrc hasn't changed\n  previousFormattedVideoSources.current = formattedVideoSources;\n\n  return formattedVideoSources;\n}\n","import { useMemo } from 'react';\nimport {\n  VideoCaptionsTrack,\n  VideoCaptionsProp,\n} from '../HoverVideoPlayer.types';\n\n/**\n * Hook takes the videoCaptions prop and formats it as a standardized array of VideoCaptionsTrack objects which can be used to render\n * <track> elements for the video\n *\n * @param {VideoCaptionsProp} videoCaptions - Captions track(s) to use for the video player for accessibility.\n *\n * @returns {VideoCaptionsTrack[]}  Array of formatted VideoCaptionsTrack objects which can be used to render <track> elements for the video\n */\nexport default function useFormatVideoCaptions(\n  videoCaptions: VideoCaptionsProp\n): VideoCaptionsTrack[] {\n  return useMemo(() => {\n    const formattedVideoCaptions = [];\n\n    // If captions were provided, format them for use for the video\n    if (videoCaptions != null) {\n      // Make sure we can treat the videoCaptions value as an array\n      const rawVideoCaptions = Array.isArray(videoCaptions)\n        ? videoCaptions\n        : [videoCaptions];\n\n      // Parse our raw video captions values into an array of formatted VideoCaptionsTrack\n      // objects that can be used to render caption tracks for the video\n      for (\n        let i = 0, numCaptions = rawVideoCaptions.length;\n        i < numCaptions;\n        i += 1\n      ) {\n        const captions = rawVideoCaptions[i];\n\n        if (captions && captions.src) {\n          formattedVideoCaptions.push({\n            src: captions.src,\n            srcLang: captions.srcLang,\n            label: captions.label,\n            kind: captions.kind || 'captions',\n            default: Boolean(captions.default),\n          });\n        } else {\n          // Log an error if one of the videoCaptions values is invalid\n          console.error(\n            \"Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'\",\n            captions\n          );\n        }\n      }\n    }\n\n    return formattedVideoCaptions;\n  }, [videoCaptions]);\n}\n","import { useState, useEffect } from 'react';\nimport { HoverTarget } from '../HoverVideoPlayer.types';\n\nconst getElementFromHoverTarget = (hoverTarget: HoverTarget) => {\n  // A `hoverTarget` value could be a function, a DOM element, or a React ref, so\n  // figure out which one it is and get the hover target element out of it accordingly\n  if (typeof hoverTarget === 'function') {\n    return hoverTarget();\n  } else if (hoverTarget instanceof Node) {\n    return hoverTarget;\n  } else if (hoverTarget && hoverTarget.hasOwnProperty('current')) {\n    return hoverTarget.current;\n  } else {\n    console.error(\n      'HoverVideoPlayer was unable to get a usable hover target element. Please check your usage of the `hoverTarget` prop.'\n    );\n  }\n};\n\n/**\n * Extracts a node to watch for hover events on from the `hoverTarget` prop.\n *\n * @param {HoverTarget} hoverTarget\n */\nexport default function useHoverTargetElement(\n  hoverTarget: HoverTarget\n): Node | null {\n  const [hoverTargetElement, setHoverTargetElement] = useState<Node | null>(\n    null\n  );\n\n  useEffect(() => {\n    setHoverTargetElement(getElementFromHoverTarget(hoverTarget));\n  }, [hoverTarget]);\n\n  return hoverTargetElement;\n}\n","import { useEffect, useRef } from 'react';\n\n/**\n * Sets up listeners for hover events on the hover target element and dispatches events\n * when the target element is hovered or unhovered.\n *\n * @param {Node} hoverTargetElement - The target element to watch for hover events on\n * @param {boolean} focused - Whether the component is being manually focused by the focused prop.\n * @param {boolean} disableDefaultEventHandling - If true, disables setting up the standard mouseenter/touchstart/focus listeners\n *                                                on the hover target element.\n * @param {func} onHoverStartCallback - Optional callback to be called when the target element is hovered.\n * @param {func} onHoverEndCallback - Optional callback to be called when the hover target element is unhovered.\n */\nexport default function useManageHoverEvents(\n  hoverTargetElement: Node,\n  focused: boolean,\n  disableDefaultEventHandling: boolean,\n  onHoverStartCallback: () => void,\n  onHoverEndCallback: () => void\n): void {\n  // Keeping hover callbacks as refs because we want to be able to access them from within our\n  // onHoverStart and onHoverEnd event listeners without needing to re-run the\n  // event setup effect every time they change\n  const onHoverStartCallbackRef = useRef<() => void>();\n  onHoverStartCallbackRef.current = onHoverStartCallback;\n\n  const onHoverEndCallbackRef = useRef<() => void>();\n  onHoverEndCallbackRef.current = onHoverEndCallback;\n\n  useEffect(() => {\n    // If default event handling is disabled, we shouldn't check for touch events outside of the player\n    if (disableDefaultEventHandling || !hoverTargetElement) return undefined;\n\n    const onHoverStart = () => {\n      hoverTargetElement.dispatchEvent(new Event('hvp:hoverStart'));\n      if (onHoverStartCallbackRef.current) onHoverStartCallbackRef.current();\n    };\n    const onHoverEnd = () => {\n      hoverTargetElement.dispatchEvent(new Event('hvp:hoverEnd'));\n      if (onHoverEndCallbackRef.current) onHoverEndCallbackRef.current();\n    };\n\n    // Mouse events\n    hoverTargetElement.addEventListener('mouseenter', onHoverStart);\n    hoverTargetElement.addEventListener('mouseleave', onHoverEnd);\n\n    // Focus/blur\n    hoverTargetElement.addEventListener('focus', onHoverStart);\n    hoverTargetElement.addEventListener('blur', onHoverEnd);\n\n    // Touch events\n    const touchStartListenerOptions = { passive: true };\n\n    hoverTargetElement.addEventListener(\n      'touchstart',\n      onHoverStart,\n      touchStartListenerOptions\n    );\n    // Event listener pauses the video when the user touches somewhere outside of the player\n    const onWindowTouchStart = (event: TouchEvent) => {\n      if (\n        !(event.target instanceof Node) ||\n        !hoverTargetElement.contains(event.target)\n      ) {\n        onHoverEnd();\n      }\n    };\n\n    window.addEventListener(\n      'touchstart',\n      onWindowTouchStart,\n      touchStartListenerOptions\n    );\n\n    // Return a cleanup function that removes all event listeners\n    return () => {\n      hoverTargetElement.removeEventListener('mouseenter', onHoverStart);\n      hoverTargetElement.removeEventListener('mouseleave', onHoverEnd);\n      hoverTargetElement.removeEventListener('focus', onHoverStart);\n      hoverTargetElement.removeEventListener('blur', onHoverEnd);\n      hoverTargetElement.removeEventListener('touchstart', onHoverStart);\n      window.removeEventListener('touchstart', onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTargetElement]);\n\n  // Defaulting the ref to false rather than the initial value of the focused prop because\n  // if focused is true initially, we want to run the effect, but if it's false, we don't\n  const previousFocusedRef = useRef<boolean>(false);\n\n  // Effect dispatches hover start/end events on the target element when the focused prop changes\n  useEffect(() => {\n    if (!hoverTargetElement) return;\n\n    if (previousFocusedRef.current !== focused) {\n      previousFocusedRef.current = focused;\n\n      if (focused) {\n        hoverTargetElement.dispatchEvent(new Event('hvp:hoverStart'));\n      } else {\n        hoverTargetElement.dispatchEvent(new Event('hvp:hoverEnd'));\n      }\n    }\n  }, [hoverTargetElement, focused]);\n}\n","/**\n * Takes a video element and returns whether it is currently paused, meaning it is not\n * playing or attempting to play.\n *\n * @param {HTMLVideoElement} videoElement\n */\nexport function isVideoElementPaused(videoElement: HTMLVideoElement): boolean {\n  return videoElement.paused || videoElement.ended;\n}\n\n/**\n * Takes a video element and returns whether it is currently loading, meaning it is not\n * paused but has also not loaded enough to play.\n *\n * @param {HTMLVideoElement} videoElement\n */\nexport function isVideoElementLoading(videoElement: HTMLVideoElement): boolean {\n  return (\n    !isVideoElementPaused(videoElement) &&\n    videoElement.readyState < videoElement.HAVE_FUTURE_DATA\n  );\n}\n\n/**\n * Takes a video element and returns whether it is currently playing, meaning it is not\n * paused and is loaded enough to be playing.\n *\n * @param {HTMLVideoElement} videoElement\n */\nexport function isVideoElementPlaying(videoElement: HTMLVideoElement): boolean {\n  return (\n    !isVideoElementPaused(videoElement) && !isVideoElementLoading(videoElement)\n  );\n}\n","import React from 'react';\n\ninterface SizingModeStyle {\n  video: React.CSSProperties;\n  overlay: React.CSSProperties;\n  container: React.CSSProperties;\n  manual: React.CSSProperties;\n}\n\n// CSS styles to make some contents in the player expand to fill the container\nexport const expandToFillContainerStyle: React.CSSProperties = {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n};\n\nconst containerMatchContentDimensionsStyle: React.CSSProperties = {\n  display: 'inline-block',\n};\n\nexport const containerSizingStyles: SizingModeStyle = {\n  video: containerMatchContentDimensionsStyle,\n  overlay: containerMatchContentDimensionsStyle,\n  container: null,\n  manual: null,\n};\n\n// Styles to apply to the paused overlay wrapper for each sizing mode\nexport const pausedOverlayWrapperSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so make the overlay\n  // expand to cover the player's container element\n  video: expandToFillContainerStyle,\n  // Sizing should be based on the paused overlay, so set position: relative\n  // to make it occupy space in the document flow\n  overlay: {\n    position: 'relative',\n  },\n  // Sizing should be based on the player's container element, so make the overlay\n  // expand to cover it\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the overlay\n  manual: null,\n};\n\n// Styles to apply to the video element for each sizing mode\nexport const videoSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so set display: block\n  // to make sure it occupies space in the document flow\n  video: {\n    display: 'block',\n    // Ensure the video is sized relative to the container's width\n    // rather than the video asset's native width\n    width: '100%',\n  },\n  // Make the video element expand to cover the container if we're sizing\n  // based on the overlay or container\n  overlay: expandToFillContainerStyle,\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the video\n  manual: null,\n};\n","import React, { useRef, useImperativeHandle, useEffect, useState } from 'react';\n\nimport useSetAdditionalAttributesOnVideo from '../hooks/useSetAdditionalAttributesOnVideo';\nimport useFormatVideoSrc from '../hooks/useFormatVideoSrc';\nimport useFormatVideoCaptions from '../hooks/useFormatVideoCaptions';\nimport useHoverTargetElement from '../hooks/useHoverTargetElement';\nimport useManageHoverEvents from '../hooks/useManageHoverEvents';\n\nimport {\n  isVideoElementPaused,\n  isVideoElementPlaying,\n} from '../utils/videoElementPlaybackStates';\n\nimport {\n  expandToFillContainerStyle,\n  containerSizingStyles,\n  pausedOverlayWrapperSizingStyles,\n  videoSizingStyles,\n} from './HoverVideoPlayer.styles';\nimport { HoverVideoPlayerProps, VideoSource } from '../HoverVideoPlayer.types';\n\n/**\n * @component HoverVideoPlayer\n * @license MIT\n *\n * @param {HoverVideoPlayerProps} props\n */\nexport default function HoverVideoPlayer({\n  videoSrc,\n  videoCaptions = null,\n  focused = false,\n  disableDefaultEventHandling = false,\n  hoverTarget = null,\n  onHoverStart = null,\n  onHoverEnd = null,\n  hoverOverlay = null,\n  pausedOverlay = null,\n  loadingOverlay = null,\n  loadingStateTimeout = 200,\n  overlayTransitionDuration = 400,\n  playbackStartDelay = 0,\n  restartOnPaused = false,\n  unloadVideoOnPaused = false,\n  playbackRangeStart = null,\n  playbackRangeEnd = null,\n  muted = true,\n  volume = 1,\n  loop = true,\n  preload = null,\n  crossOrigin = null,\n  controls = false,\n  controlsList = null,\n  disableRemotePlayback = true,\n  disablePictureInPicture = true,\n  style = null,\n  hoverOverlayWrapperClassName = null,\n  hoverOverlayWrapperStyle = null,\n  pausedOverlayWrapperClassName = null,\n  pausedOverlayWrapperStyle = null,\n  loadingOverlayWrapperClassName = null,\n  loadingOverlayWrapperStyle = null,\n  videoId = null,\n  videoClassName = null,\n  videoRef: forwardedVideoRef = null,\n  videoStyle = null,\n  sizingMode = 'video',\n  shouldSuppressPlaybackInterruptedErrors = true,\n  ...spreadableProps\n}: HoverVideoPlayerProps): JSX.Element {\n  // Element refs\n  const containerRef = useRef(null);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  // Forward out local videoRef along to the videoRef prop\n  useImperativeHandle(forwardedVideoRef, () => videoRef.current);\n\n  // Effect sets attributes on the video which can't be done via props\n  useSetAdditionalAttributesOnVideo(\n    videoRef,\n    muted,\n    volume,\n    disableRemotePlayback,\n    disablePictureInPicture\n  );\n\n  // Get the hover target element from the hoverTarget prop, or default to the component's container div\n  const hoverTargetElement = useHoverTargetElement(hoverTarget || containerRef);\n\n  // Keep a ref for the time which the video should be started from next time it is played\n  // This is useful if the video gets unloaded and we want to restore it to the time it was\n  // at before if the user tries playing it again\n  const nextVideoStartTimeRef = useRef(null);\n\n  // Parse the sources and captions into formatted arrays that we can use to\n  // render <source> and <track> elements for the video\n  const formattedVideoCaptions = useFormatVideoCaptions(videoCaptions);\n  const formattedVideoSources = useFormatVideoSrc(\n    videoSrc,\n    playbackRangeStart,\n    playbackRangeEnd\n  );\n  // Keep a ref to the previous formatted video sources so we can track when the video sources change\n  const previousFormattedVideoSourcesRef = useRef<VideoSource[]>(\n    formattedVideoSources\n  );\n\n  /**\n   * Attempts to load and play the video.\n   * Storing this on a ref because we don't really want to worry about triggering re-renders when\n   * any of this function's dependencies change; it should only be called when the\n   * player is hovered/focused.\n   */\n  const attemptToPlayVideoRef = useRef<() => void>();\n  attemptToPlayVideoRef.current = () => {\n    const videoElement = videoRef.current;\n\n    if (nextVideoStartTimeRef.current !== null) {\n      videoElement.currentTime = nextVideoStartTimeRef.current;\n    }\n\n    videoElement.play().catch((error: DOMException) => {\n      // If shouldSuppressPlaybackInterruptedErrors is true and this is an AbortError, do nothing instead of logging it.\n      if (\n        shouldSuppressPlaybackInterruptedErrors &&\n        error.name === 'AbortError'\n      ) {\n        return;\n      }\n\n      // Additional handling for when browsers block playback for unmuted videos.\n      // This is unfortunately necessary because most modern browsers do not allow playing videos with audio\n      //  until the user has \"interacted\" with the page by clicking somewhere at least once; mouseenter events\n      //  don't count.\n      // If the video isn't muted and playback failed with a `NotAllowedError`, this means the browser blocked\n      // playing the video because the user hasn't clicked anywhere on the page yet.\n      if (!videoElement.muted && error.name === 'NotAllowedError') {\n        console.warn(\n          'HoverVideoPlayer: Playback with sound was blocked by the browser. Attempting to play again with the video muted; audio will be restored if the user clicks on the page.'\n        );\n        // Mute the video and attempt to play again\n        videoElement.muted = true;\n        videoElement.play();\n\n        // When the user clicks on the document, unmute the video since we should now\n        // be free to play audio\n        const onClickDocument = () => {\n          videoElement.muted = false;\n\n          // Clean up the event listener so it is only fired once\n          document.removeEventListener('click', onClickDocument);\n        };\n        document.addEventListener('click', onClickDocument);\n      } else {\n        // Log any other playback errors with console.error\n        console.error(`HoverVideoPlayer: ${error.message}`);\n      }\n    });\n  };\n\n  /**\n   * Attempts to pause the video.\n   * Storing this on a ref because we don't really want to worry about triggering re-renders when\n   * any of this function's dependencies change; it should only be called when the\n   * player is un-hovered/focused.\n   */\n  const attemptToPauseVideoRef = useRef<() => void>();\n  attemptToPauseVideoRef.current = () => {\n    const videoElement = videoRef.current;\n\n    videoElement.pause();\n\n    // Performing post-save cleanup tasks in here rather than the onPause listener\n    // because onPause can also be called when the video reaches the end of a playback range\n    // and it's just simpler to deal with that separately\n    if (restartOnPaused) {\n      videoElement.currentTime = playbackRangeStart || 0;\n    }\n    nextVideoStartTimeRef.current = videoElement.currentTime;\n\n    setIsPlaying(false);\n  };\n\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isHovering, setIsHovering] = useState(false);\n\n  useEffect(() => {\n    if (!isPlaying) {\n      // When the video isn't playing, check if the sources loaded in the video\n      // have changed from what the video currently has loaded. If so, we'll call videoElement.load()\n      // to trigger a reload with the new source\n      const shouldReloadVideoSources =\n        previousFormattedVideoSourcesRef.current !== formattedVideoSources;\n\n      if (shouldReloadVideoSources) {\n        previousFormattedVideoSourcesRef.current = formattedVideoSources;\n\n        const videoElement = videoRef.current;\n        // If the video element doesn't have a loaded source or the source has changed since the\n        // last time we played the video, make sure to force the video to load the most up-to-date sources\n        videoElement.load();\n        // Reset the next start time to the start of the video\n        nextVideoStartTimeRef.current = playbackRangeStart || 0;\n      }\n    }\n  }, [formattedVideoSources, isPlaying, playbackRangeStart]);\n\n  const hasPausedOverlay = Boolean(pausedOverlay);\n  const hasHoverOverlay = Boolean(hoverOverlay);\n\n  // If we have a paused or hover overlay, the player should wait\n  // for the overlay(s) to finish transitioning back in before we\n  // pause the video\n  const shouldWaitForOverlayTransitionBeforePausing =\n    hasPausedOverlay || hasHoverOverlay;\n\n  useEffect(() => {\n    if (!hoverTargetElement) return undefined;\n\n    let playbackStartTimeout: number | null = null;\n    let pauseTimeout: number | null = null;\n\n    const cancelTimeouts = () => {\n      // Cancel any previously active pause or playback attempts\n      window.clearTimeout(playbackStartTimeout);\n      window.clearTimeout(pauseTimeout);\n    };\n\n    const attemptToPlayVideoOnHover = () => {\n      cancelTimeouts();\n\n      setIsHovering(true);\n\n      // We only need to attempt to play if the video is currently paused\n      if (isVideoElementPaused(videoRef.current)) {\n        if (playbackStartDelay) {\n          playbackStartTimeout = window.setTimeout(\n            () => attemptToPlayVideoRef.current(),\n            playbackStartDelay\n          );\n        } else {\n          attemptToPlayVideoRef.current();\n        }\n      }\n    };\n    const attemptToPauseVideoOnHoverEnd = () => {\n      cancelTimeouts();\n\n      setIsHovering(false);\n\n      if (\n        // We only need to delay a pause attempt if the video is currently playing\n        isVideoElementPlaying(videoRef.current) &&\n        shouldWaitForOverlayTransitionBeforePausing\n      ) {\n        pauseTimeout = window.setTimeout(\n          () => attemptToPauseVideoRef.current(),\n          overlayTransitionDuration\n        );\n      } else {\n        attemptToPauseVideoRef.current();\n      }\n    };\n\n    hoverTargetElement.addEventListener(\n      'hvp:hoverStart',\n      attemptToPlayVideoOnHover\n    );\n    hoverTargetElement.addEventListener(\n      'hvp:hoverEnd',\n      attemptToPauseVideoOnHoverEnd\n    );\n\n    return () => {\n      hoverTargetElement.removeEventListener(\n        'hvp:hoverStart',\n        attemptToPlayVideoOnHover\n      );\n      hoverTargetElement.removeEventListener(\n        'hvp:hoverEnd',\n        attemptToPauseVideoOnHoverEnd\n      );\n      cancelTimeouts();\n    };\n  }, [\n    hoverTargetElement,\n    overlayTransitionDuration,\n    playbackStartDelay,\n    shouldWaitForOverlayTransitionBeforePausing,\n  ]);\n\n  useManageHoverEvents(\n    hoverTargetElement,\n    focused,\n    disableDefaultEventHandling,\n    onHoverStart,\n    onHoverEnd\n  );\n\n  // We should attempt to play the video if the user is hovering over it or the `focused` override prop is enabled\n  // const shouldPlayVideo = isHoveringOverVideo || focused;\n\n  const hasLoadingOverlay = Boolean(loadingOverlay);\n\n  // If the video's sources should be unloaded when it's paused and the video is not currently active, we can unload the video's sources.\n  // We will remove the video's <source> tags in this render and then call video.load() in an effect to\n  // fully unload the video\n  const shouldUnloadVideo = unloadVideoOnPaused && !isHovering && !isPlaying;\n\n  useEffect(() => {\n    // If shouldUnloadVideo is true, this effect is being run after the video's\n    // sources have been removed, so call load on the video to unload any sources it currently has loaded\n    if (shouldUnloadVideo) {\n      const videoElement = videoRef.current;\n      videoElement.load();\n    }\n  }, [shouldUnloadVideo]);\n\n  const shouldShowLoadingOverlay = isHovering && !isPlaying;\n  // Show a paused overlay when the user isn't hovering or when the user is hovering\n  // but the video is still loading\n  const shouldShowPausedOverlay = !isHovering || (isHovering && !isPlaying);\n\n  const isUsingPlaybackRange =\n    playbackRangeStart !== null || playbackRangeEnd !== null;\n\n  return (\n    <div\n      data-testid=\"hover-video-player-container\"\n      ref={containerRef}\n      style={{\n        ...containerSizingStyles[sizingMode],\n        position: 'relative',\n        ...style,\n      }}\n      {...spreadableProps}\n    >\n      {hasPausedOverlay ? (\n        <div\n          style={{\n            ...pausedOverlayWrapperSizingStyles[sizingMode],\n            zIndex: 1,\n            opacity: shouldShowPausedOverlay ? 1 : 0,\n            transition: `opacity ${overlayTransitionDuration}ms`,\n            // Disable pointer events on the paused overlay when it's hidden\n            pointerEvents: shouldShowPausedOverlay ? 'auto' : 'none',\n            ...pausedOverlayWrapperStyle,\n          }}\n          className={pausedOverlayWrapperClassName}\n          data-testid=\"paused-overlay-wrapper\"\n        >\n          {pausedOverlay}\n        </div>\n      ) : null}\n      {hasLoadingOverlay ? (\n        <div\n          style={{\n            ...expandToFillContainerStyle,\n            zIndex: 2,\n            opacity: shouldShowLoadingOverlay ? 1 : 0,\n            transition: `opacity ${overlayTransitionDuration}ms ${\n              shouldShowLoadingOverlay ? loadingStateTimeout : 0\n            }ms`,\n            // Disable pointer events on the loading overlay when it's hidden\n            pointerEvents: shouldShowLoadingOverlay ? 'auto' : 'none',\n            ...loadingOverlayWrapperStyle,\n          }}\n          className={loadingOverlayWrapperClassName}\n          data-testid=\"loading-overlay-wrapper\"\n        >\n          {loadingOverlay}\n        </div>\n      ) : null}\n      {hasHoverOverlay ? (\n        <div\n          style={{\n            ...expandToFillContainerStyle,\n            zIndex: 3,\n            // Show the hover overlay when the player is hovered/playing\n            opacity: isHovering ? 1 : 0,\n            transition: `opacity ${overlayTransitionDuration}ms`,\n            // Disable pointer events on the hover overlay when it's hidden\n            pointerEvents: isHovering ? 'auto' : 'none',\n            ...hoverOverlayWrapperStyle,\n          }}\n          className={hoverOverlayWrapperClassName}\n          data-testid=\"hover-overlay-wrapper\"\n        >\n          {hoverOverlay}\n        </div>\n      ) : null}\n      {/* eslint-disable-next-line jsx-a11y/media-has-caption */}\n      <video\n        // If a playback range is set, the loop attribute will not work correctly so there's no point in setting it here;\n        // in that case, we will manually implement this behavior\n        loop={isUsingPlaybackRange ? false : loop}\n        playsInline\n        preload={preload}\n        crossOrigin={crossOrigin}\n        ref={videoRef}\n        style={{\n          ...videoSizingStyles[sizingMode],\n          objectFit: 'cover',\n          ...videoStyle,\n        }}\n        controls={controls}\n        controlsList={controlsList}\n        className={videoClassName}\n        id={videoId}\n        data-testid=\"video-element\"\n        onPlaying={() => {\n          setIsPlaying(true);\n        }}\n        onTimeUpdate={\n          // If there's a playback range set, the traditional `loop` video prop won't work correctly so\n          // we'll need watch the video's time as it plays and manually keep it within the bounds of the range\n          isUsingPlaybackRange\n            ? () => {\n                const videoElement = videoRef.current;\n\n                const maxVideoTime = playbackRangeEnd || videoElement.duration;\n                const minVideoTime = playbackRangeStart || 0;\n\n                const { currentTime } = videoElement;\n\n                if (loop && currentTime >= maxVideoTime) {\n                  // If the video should loop and is >= the max video time,\n                  // loop it back around to the start\n                  const startTime = playbackRangeStart || 0;\n                  videoElement.currentTime = startTime;\n\n                  // If the video is paused but the user is still hovering,\n                  // meaning it should continue to play, call play() to keep it going\n                  if (isHovering && isVideoElementPaused(videoElement)) {\n                    videoElement.play();\n                  }\n                } else if (currentTime > maxVideoTime) {\n                  // If the video shouldn't loop but we've exceeded the max video time,\n                  // clamp it to the max time and pause it\n                  videoElement.pause();\n                  videoElement.currentTime = maxVideoTime;\n                } else if (currentTime < minVideoTime) {\n                  // If the video's time somehow ended up before the min video time,\n                  // clamp it to the min time\n                  videoElement.currentTime = minVideoTime;\n                }\n              }\n            : null\n        }\n      >\n        {!shouldUnloadVideo &&\n          // Only render sources for the video if it is not unloaded\n          formattedVideoSources.map(({ src, type }) => (\n            <source key={src} src={src} type={type} />\n          ))}\n        {formattedVideoCaptions.map(\n          ({ src, srcLang, label, kind, default: isDefault }) => (\n            <track\n              key={src}\n              kind={kind}\n              src={src}\n              srcLang={srcLang}\n              label={label}\n              default={isDefault}\n            />\n          )\n        )}\n      </video>\n    </div>\n  );\n}\n"],"names":["useEffect","useRef","useMemo","useState","useImperativeHandle","React"],"mappings":"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"}