import React, { useEffect, useRef, useMemo, useState, useImperativeHandle } from 'react';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * Hook handles manually setting some additional attributes on the video that
 * can't be set directly via attributes on the element.
 *
 * @param {React.RefObject<HTMLVideoElement>} videoRef - Ref to the video element
 * @param {bool} muted - Whether the video should be muted
 * @param {number} volume - The volume level that the video's audio should be set to
 * @param {bool} disableRemotePlayback - Whether we want to disable showing controls to cast the video
 * @param {bool} disablePictureInPicture - Whether we want to disable showing controls to play the video in picture-in-picture mode
 */
function useSetAdditionalAttributesOnVideo(videoRef, muted, volume, disableRemotePlayback, disablePictureInPicture) {
    useEffect(function () {
        var videoElement = videoRef.current;
        // Manually setting the `muted` attribute on the video element via an effect in order
        // to avoid a know React issue with the `muted` prop not applying correctly on initial render
        // https://github.com/facebook/react/issues/10389
        videoElement.muted = muted;
        // Set the video's volume to match the `volume` prop
        // Note that this will have no effect if the `muted` prop is set to true
        videoElement.volume = volume;
    }, [videoRef, muted, volume]);
    useEffect(function () {
        var videoElement = videoRef.current;
        // React does not support directly setting disableRemotePlayback or disablePictureInPicture directly
        // via the video element's props, so we have to manually set them in an effect
        videoElement.disableRemotePlayback = disableRemotePlayback;
        videoElement.disablePictureInPicture = disablePictureInPicture;
    }, [videoRef, disablePictureInPicture, disableRemotePlayback]);
}

/**
 * @function  formatVideoSrc
 *
 * Hook takes the videoSrc prop and formats it as a standardized array of VideoSource objects which can be used to render
 * <source> elements for the video
 *
 * @param {VideoSrcProp}  videoSrc - Source(s) to format into VideoSource objects so they can be added to the video player.
 * @param {number}  playbackRangeStart - The earliest time in seconds that we should start loading the video from.
 *                                        This will be enforced by using a #t media fragment identifier to tell the browser to only
 *                                        load the video starting from this time.
 *                                        If not provided, we will load from the start of the video.
 * @param {number}  playbackRangeEnd - The maximum time in seconds that we should load the video to.
 *                                        This will be enforced by using a #t media fragment identifier to tell the browser to only
 *                                        load the video up to this time.
 *                                        If not provided, we will load to the end of the video.
 *
 * @returns {VideoSource[]} Array of formatted VideoSource objects which can be used to render <source> elements for the video
 */
function useFormatVideoSrc(videoSrc, playbackRangeStart, playbackRangeEnd) {
    var previousVideoSrc = useRef(null);
    var previousFormattedVideoSources = useRef(null);
    // If videoSrc is shallowly equal with the previous videoSrc we can just return the previous formatted video sources
    if (previousVideoSrc.current !== null &&
        videoSrc === previousVideoSrc.current) {
        return previousFormattedVideoSources.current;
    }
    // Store the previous videoSrc so we can compare it on the next render
    previousVideoSrc.current = videoSrc;
    var formattedVideoSources = [];
    if (videoSrc == null) {
        // A videoSrc value is required in order to make the video player work
        console.error("Error: 'videoSrc' prop is required for HoverVideoPlayer component");
    }
    else {
        // Make sure we can treat the videoSrc value as an array
        var rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc];
        // Parse our video source values into an array of VideoSource objects that can be used to render sources for the video
        for (var i = 0, numSources = rawVideoSources.length; i < numSources; i += 1) {
            var source = rawVideoSources[i];
            var hasPlaybackRangeStart = playbackRangeStart !== null;
            var hasPlaybackRangeEnd = playbackRangeEnd !== null;
            // Construct a media fragment identifier string to append to the video's URL to ensure
            // we only load the portion of the video that we need for the provided playback range
            // (see here for more details: https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery#specifying_playback_range)
            var playbackRangeMediaFragmentIdentifier = hasPlaybackRangeStart || hasPlaybackRangeEnd
                ? // If we have a playback range defined, construct a #t media fragment identifier string
                    // This identifier follows the format `#t=[starttime][,endtime]` and will tell the browser to only load the video file
                    // within this defined time range.
                    // This helps save us from loading some unneeded data when we only need whatever is within the playback range!
                    "#t=".concat(hasPlaybackRangeStart ? playbackRangeStart : '').concat(hasPlaybackRangeEnd ? ",".concat(playbackRangeEnd) : '')
                : '';
            if (typeof source === 'string') {
                // If the source is a string, it's an src URL so format it into a VideoSource object and add it to the array
                formattedVideoSources.push({
                    src: "".concat(source).concat(playbackRangeMediaFragmentIdentifier),
                });
            }
            else if (source && source.src) {
                // If the source is an object with an src, just add it to the array
                formattedVideoSources.push({
                    src: "".concat(source.src).concat(playbackRangeMediaFragmentIdentifier),
                    type: source.type,
                });
            }
            else {
                // Log an error if one of the videoSrc values is invalid
                console.error("Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':", source);
            }
        }
    }
    // If our formatted video sources are deeply equal to the previous formatted sources
    // based on a simple string comparison, return the previous formatted sources instead to maintain
    // referential equality
    if (JSON.stringify(formattedVideoSources) ===
        JSON.stringify(previousFormattedVideoSources.current)) {
        return previousFormattedVideoSources.current;
    }
    // Store the final formatted video sources so we can return them on subsequent renders
    // if the videoSrc hasn't changed
    previousFormattedVideoSources.current = formattedVideoSources;
    return formattedVideoSources;
}

/**
 * Hook takes the videoCaptions prop and formats it as a standardized array of VideoCaptionsTrack objects which can be used to render
 * <track> elements for the video
 *
 * @param {VideoCaptionsProp} videoCaptions - Captions track(s) to use for the video player for accessibility.
 *
 * @returns {VideoCaptionsTrack[]}  Array of formatted VideoCaptionsTrack objects which can be used to render <track> elements for the video
 */
function useFormatVideoCaptions(videoCaptions) {
    return useMemo(function () {
        var formattedVideoCaptions = [];
        // If captions were provided, format them for use for the video
        if (videoCaptions != null) {
            // Make sure we can treat the videoCaptions value as an array
            var rawVideoCaptions = Array.isArray(videoCaptions)
                ? videoCaptions
                : [videoCaptions];
            // Parse our raw video captions values into an array of formatted VideoCaptionsTrack
            // objects that can be used to render caption tracks for the video
            for (var i = 0, numCaptions = rawVideoCaptions.length; i < numCaptions; i += 1) {
                var captions = rawVideoCaptions[i];
                if (captions && captions.src) {
                    formattedVideoCaptions.push({
                        src: captions.src,
                        srcLang: captions.srcLang,
                        label: captions.label,
                        kind: captions.kind || 'captions',
                        default: Boolean(captions.default),
                    });
                }
                else {
                    // Log an error if one of the videoCaptions values is invalid
                    console.error("Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'", captions);
                }
            }
        }
        return formattedVideoCaptions;
    }, [videoCaptions]);
}

var getElementFromHoverTarget = function (hoverTarget) {
    // A `hoverTarget` value could be a function, a DOM element, or a React ref, so
    // figure out which one it is and get the hover target element out of it accordingly
    if (typeof hoverTarget === 'function') {
        return hoverTarget();
    }
    else if (hoverTarget instanceof Node) {
        return hoverTarget;
    }
    else if (hoverTarget && hoverTarget.hasOwnProperty('current')) {
        return hoverTarget.current;
    }
    else {
        console.error('HoverVideoPlayer was unable to get a usable hover target element. Please check your usage of the `hoverTarget` prop.');
    }
};
/**
 * Extracts a node to watch for hover events on from the `hoverTarget` prop.
 *
 * @param {HoverTarget} hoverTarget
 */
function useHoverTargetElement(hoverTarget) {
    var _a = useState(null), hoverTargetElement = _a[0], setHoverTargetElement = _a[1];
    useEffect(function () {
        setHoverTargetElement(getElementFromHoverTarget(hoverTarget));
    }, [hoverTarget]);
    return hoverTargetElement;
}

/**
 * Sets up listeners for hover events on the hover target element and dispatches events
 * when the target element is hovered or unhovered.
 *
 * @param {Node} hoverTargetElement - The target element to watch for hover events on
 * @param {boolean} focused - Whether the component is being manually focused by the focused prop.
 * @param {boolean} disableDefaultEventHandling - If true, disables setting up the standard mouseenter/touchstart/focus listeners
 *                                                on the hover target element.
 * @param {func} onHoverStartCallback - Optional callback to be called when the target element is hovered.
 * @param {func} onHoverEndCallback - Optional callback to be called when the hover target element is unhovered.
 */
function useManageHoverEvents(hoverTargetElement, focused, disableDefaultEventHandling, onHoverStartCallback, onHoverEndCallback) {
    // Keeping hover callbacks as refs because we want to be able to access them from within our
    // onHoverStart and onHoverEnd event listeners without needing to re-run the
    // event setup effect every time they change
    var onHoverStartCallbackRef = useRef();
    onHoverStartCallbackRef.current = onHoverStartCallback;
    var onHoverEndCallbackRef = useRef();
    onHoverEndCallbackRef.current = onHoverEndCallback;
    useEffect(function () {
        // If default event handling is disabled, we shouldn't check for touch events outside of the player
        if (disableDefaultEventHandling || !hoverTargetElement)
            return undefined;
        var onHoverStart = function () {
            hoverTargetElement.dispatchEvent(new Event('hvp:hoverStart'));
            if (onHoverStartCallbackRef.current)
                onHoverStartCallbackRef.current();
        };
        var onHoverEnd = function () {
            hoverTargetElement.dispatchEvent(new Event('hvp:hoverEnd'));
            if (onHoverEndCallbackRef.current)
                onHoverEndCallbackRef.current();
        };
        // Mouse events
        hoverTargetElement.addEventListener('mouseenter', onHoverStart);
        hoverTargetElement.addEventListener('mouseleave', onHoverEnd);
        // Focus/blur
        hoverTargetElement.addEventListener('focus', onHoverStart);
        hoverTargetElement.addEventListener('blur', onHoverEnd);
        // Touch events
        var touchStartListenerOptions = { passive: true };
        hoverTargetElement.addEventListener('touchstart', onHoverStart, touchStartListenerOptions);
        // Event listener pauses the video when the user touches somewhere outside of the player
        var onWindowTouchStart = function (event) {
            if (!(event.target instanceof Node) ||
                !hoverTargetElement.contains(event.target)) {
                onHoverEnd();
            }
        };
        window.addEventListener('touchstart', onWindowTouchStart, touchStartListenerOptions);
        // Return a cleanup function that removes all event listeners
        return function () {
            hoverTargetElement.removeEventListener('mouseenter', onHoverStart);
            hoverTargetElement.removeEventListener('mouseleave', onHoverEnd);
            hoverTargetElement.removeEventListener('focus', onHoverStart);
            hoverTargetElement.removeEventListener('blur', onHoverEnd);
            hoverTargetElement.removeEventListener('touchstart', onHoverStart);
            window.removeEventListener('touchstart', onWindowTouchStart);
        };
    }, [disableDefaultEventHandling, hoverTargetElement]);
    // Defaulting the ref to false rather than the initial value of the focused prop because
    // if focused is true initially, we want to run the effect, but if it's false, we don't
    var previousFocusedRef = useRef(false);
    // Effect dispatches hover start/end events on the target element when the focused prop changes
    useEffect(function () {
        if (!hoverTargetElement)
            return;
        if (previousFocusedRef.current !== focused) {
            previousFocusedRef.current = focused;
            if (focused) {
                hoverTargetElement.dispatchEvent(new Event('hvp:hoverStart'));
            }
            else {
                hoverTargetElement.dispatchEvent(new Event('hvp:hoverEnd'));
            }
        }
    }, [hoverTargetElement, focused]);
}

/**
 * Takes a video element and returns whether it is currently paused, meaning it is not
 * playing or attempting to play.
 *
 * @param {HTMLVideoElement} videoElement
 */
function isVideoElementPaused(videoElement) {
    return videoElement.paused || videoElement.ended;
}
/**
 * Takes a video element and returns whether it is currently loading, meaning it is not
 * paused but has also not loaded enough to play.
 *
 * @param {HTMLVideoElement} videoElement
 */
function isVideoElementLoading(videoElement) {
    return (!isVideoElementPaused(videoElement) &&
        videoElement.readyState < videoElement.HAVE_FUTURE_DATA);
}
/**
 * Takes a video element and returns whether it is currently playing, meaning it is not
 * paused and is loaded enough to be playing.
 *
 * @param {HTMLVideoElement} videoElement
 */
function isVideoElementPlaying(videoElement) {
    return (!isVideoElementPaused(videoElement) && !isVideoElementLoading(videoElement));
}

// CSS styles to make some contents in the player expand to fill the container
var expandToFillContainerStyle = {
    position: 'absolute',
    width: '100%',
    height: '100%',
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
};
var containerMatchContentDimensionsStyle = {
    display: 'inline-block',
};
var containerSizingStyles = {
    video: containerMatchContentDimensionsStyle,
    overlay: containerMatchContentDimensionsStyle,
    container: null,
    manual: null,
};
// Styles to apply to the paused overlay wrapper for each sizing mode
var pausedOverlayWrapperSizingStyles = {
    // Sizing should be based on the video element, so make the overlay
    // expand to cover the player's container element
    video: expandToFillContainerStyle,
    // Sizing should be based on the paused overlay, so set position: relative
    // to make it occupy space in the document flow
    overlay: {
        position: 'relative',
    },
    // Sizing should be based on the player's container element, so make the overlay
    // expand to cover it
    container: expandToFillContainerStyle,
    // Don't apply any preset styling to the overlay
    manual: null,
};
// Styles to apply to the video element for each sizing mode
var videoSizingStyles = {
    // Sizing should be based on the video element, so set display: block
    // to make sure it occupies space in the document flow
    video: {
        display: 'block',
        // Ensure the video is sized relative to the container's width
        // rather than the video asset's native width
        width: '100%',
    },
    // Make the video element expand to cover the container if we're sizing
    // based on the overlay or container
    overlay: expandToFillContainerStyle,
    container: expandToFillContainerStyle,
    // Don't apply any preset styling to the video
    manual: null,
};

/**
 * @component HoverVideoPlayer
 * @license MIT
 *
 * @param {HoverVideoPlayerProps} props
 */
function HoverVideoPlayer(_a) {
    var videoSrc = _a.videoSrc, _b = _a.videoCaptions, videoCaptions = _b === void 0 ? null : _b, _c = _a.focused, focused = _c === void 0 ? false : _c, _d = _a.disableDefaultEventHandling, disableDefaultEventHandling = _d === void 0 ? false : _d, _e = _a.hoverTarget, hoverTarget = _e === void 0 ? null : _e, _f = _a.onHoverStart, onHoverStart = _f === void 0 ? null : _f, _g = _a.onHoverEnd, onHoverEnd = _g === void 0 ? null : _g, _h = _a.hoverOverlay, hoverOverlay = _h === void 0 ? null : _h, _j = _a.pausedOverlay, pausedOverlay = _j === void 0 ? null : _j, _k = _a.loadingOverlay, loadingOverlay = _k === void 0 ? null : _k, _l = _a.loadingStateTimeout, loadingStateTimeout = _l === void 0 ? 200 : _l, _m = _a.overlayTransitionDuration, overlayTransitionDuration = _m === void 0 ? 400 : _m, _o = _a.playbackStartDelay, playbackStartDelay = _o === void 0 ? 0 : _o, _p = _a.restartOnPaused, restartOnPaused = _p === void 0 ? false : _p, _q = _a.unloadVideoOnPaused, unloadVideoOnPaused = _q === void 0 ? false : _q, _r = _a.playbackRangeStart, playbackRangeStart = _r === void 0 ? null : _r, _s = _a.playbackRangeEnd, playbackRangeEnd = _s === void 0 ? null : _s, _t = _a.muted, muted = _t === void 0 ? true : _t, _u = _a.volume, volume = _u === void 0 ? 1 : _u, _v = _a.loop, loop = _v === void 0 ? true : _v, _w = _a.preload, preload = _w === void 0 ? null : _w, _x = _a.crossOrigin, crossOrigin = _x === void 0 ? null : _x, _y = _a.controls, controls = _y === void 0 ? false : _y, _z = _a.controlsList, controlsList = _z === void 0 ? null : _z, _0 = _a.disableRemotePlayback, disableRemotePlayback = _0 === void 0 ? true : _0, _1 = _a.disablePictureInPicture, disablePictureInPicture = _1 === void 0 ? true : _1, _2 = _a.style, style = _2 === void 0 ? null : _2, _3 = _a.hoverOverlayWrapperClassName, hoverOverlayWrapperClassName = _3 === void 0 ? null : _3, _4 = _a.hoverOverlayWrapperStyle, hoverOverlayWrapperStyle = _4 === void 0 ? null : _4, _5 = _a.pausedOverlayWrapperClassName, pausedOverlayWrapperClassName = _5 === void 0 ? null : _5, _6 = _a.pausedOverlayWrapperStyle, pausedOverlayWrapperStyle = _6 === void 0 ? null : _6, _7 = _a.loadingOverlayWrapperClassName, loadingOverlayWrapperClassName = _7 === void 0 ? null : _7, _8 = _a.loadingOverlayWrapperStyle, loadingOverlayWrapperStyle = _8 === void 0 ? null : _8, _9 = _a.videoId, videoId = _9 === void 0 ? null : _9, _10 = _a.videoClassName, videoClassName = _10 === void 0 ? null : _10, _11 = _a.videoRef, forwardedVideoRef = _11 === void 0 ? null : _11, _12 = _a.videoStyle, videoStyle = _12 === void 0 ? null : _12, _13 = _a.sizingMode, sizingMode = _13 === void 0 ? 'video' : _13, _14 = _a.shouldSuppressPlaybackInterruptedErrors, shouldSuppressPlaybackInterruptedErrors = _14 === void 0 ? true : _14, spreadableProps = __rest(_a, ["videoSrc", "videoCaptions", "focused", "disableDefaultEventHandling", "hoverTarget", "onHoverStart", "onHoverEnd", "hoverOverlay", "pausedOverlay", "loadingOverlay", "loadingStateTimeout", "overlayTransitionDuration", "playbackStartDelay", "restartOnPaused", "unloadVideoOnPaused", "playbackRangeStart", "playbackRangeEnd", "muted", "volume", "loop", "preload", "crossOrigin", "controls", "controlsList", "disableRemotePlayback", "disablePictureInPicture", "style", "hoverOverlayWrapperClassName", "hoverOverlayWrapperStyle", "pausedOverlayWrapperClassName", "pausedOverlayWrapperStyle", "loadingOverlayWrapperClassName", "loadingOverlayWrapperStyle", "videoId", "videoClassName", "videoRef", "videoStyle", "sizingMode", "shouldSuppressPlaybackInterruptedErrors"]);
    // Element refs
    var containerRef = useRef(null);
    var videoRef = useRef(null);
    // Forward out local videoRef along to the videoRef prop
    useImperativeHandle(forwardedVideoRef, function () { return videoRef.current; });
    // Effect sets attributes on the video which can't be done via props
    useSetAdditionalAttributesOnVideo(videoRef, muted, volume, disableRemotePlayback, disablePictureInPicture);
    // Get the hover target element from the hoverTarget prop, or default to the component's container div
    var hoverTargetElement = useHoverTargetElement(hoverTarget || containerRef);
    // Keep a ref for the time which the video should be started from next time it is played
    // This is useful if the video gets unloaded and we want to restore it to the time it was
    // at before if the user tries playing it again
    var nextVideoStartTimeRef = useRef(null);
    // Parse the sources and captions into formatted arrays that we can use to
    // render <source> and <track> elements for the video
    var formattedVideoCaptions = useFormatVideoCaptions(videoCaptions);
    var formattedVideoSources = useFormatVideoSrc(videoSrc, playbackRangeStart, playbackRangeEnd);
    // Keep a ref to the previous formatted video sources so we can track when the video sources change
    var previousFormattedVideoSourcesRef = useRef(formattedVideoSources);
    /**
     * Attempts to load and play the video.
     * Storing this on a ref because we don't really want to worry about triggering re-renders when
     * any of this function's dependencies change; it should only be called when the
     * player is hovered/focused.
     */
    var attemptToPlayVideoRef = useRef();
    attemptToPlayVideoRef.current = function () {
        var videoElement = videoRef.current;
        if (nextVideoStartTimeRef.current !== null) {
            videoElement.currentTime = nextVideoStartTimeRef.current;
        }
        videoElement.play().catch(function (error) {
            // If shouldSuppressPlaybackInterruptedErrors is true and this is an AbortError, do nothing instead of logging it.
            if (shouldSuppressPlaybackInterruptedErrors &&
                error.name === 'AbortError') {
                return;
            }
            // Additional handling for when browsers block playback for unmuted videos.
            // This is unfortunately necessary because most modern browsers do not allow playing videos with audio
            //  until the user has "interacted" with the page by clicking somewhere at least once; mouseenter events
            //  don't count.
            // If the video isn't muted and playback failed with a `NotAllowedError`, this means the browser blocked
            // playing the video because the user hasn't clicked anywhere on the page yet.
            if (!videoElement.muted && error.name === 'NotAllowedError') {
                console.warn('HoverVideoPlayer: Playback with sound was blocked by the browser. Attempting to play again with the video muted; audio will be restored if the user clicks on the page.');
                // Mute the video and attempt to play again
                videoElement.muted = true;
                videoElement.play();
                // When the user clicks on the document, unmute the video since we should now
                // be free to play audio
                var onClickDocument_1 = function () {
                    videoElement.muted = false;
                    // Clean up the event listener so it is only fired once
                    document.removeEventListener('click', onClickDocument_1);
                };
                document.addEventListener('click', onClickDocument_1);
            }
            else {
                // Log any other playback errors with console.error
                console.error("HoverVideoPlayer: ".concat(error.message));
            }
        });
    };
    /**
     * Attempts to pause the video.
     * Storing this on a ref because we don't really want to worry about triggering re-renders when
     * any of this function's dependencies change; it should only be called when the
     * player is un-hovered/focused.
     */
    var attemptToPauseVideoRef = useRef();
    attemptToPauseVideoRef.current = function () {
        var videoElement = videoRef.current;
        videoElement.pause();
        // Performing post-save cleanup tasks in here rather than the onPause listener
        // because onPause can also be called when the video reaches the end of a playback range
        // and it's just simpler to deal with that separately
        if (restartOnPaused) {
            videoElement.currentTime = playbackRangeStart || 0;
        }
        nextVideoStartTimeRef.current = videoElement.currentTime;
        setIsPlaying(false);
    };
    var _15 = useState(false), isPlaying = _15[0], setIsPlaying = _15[1];
    var _16 = useState(false), isHovering = _16[0], setIsHovering = _16[1];
    useEffect(function () {
        if (!isPlaying) {
            // When the video isn't playing, check if the sources loaded in the video
            // have changed from what the video currently has loaded. If so, we'll call videoElement.load()
            // to trigger a reload with the new source
            var shouldReloadVideoSources = previousFormattedVideoSourcesRef.current !== formattedVideoSources;
            if (shouldReloadVideoSources) {
                previousFormattedVideoSourcesRef.current = formattedVideoSources;
                var videoElement = videoRef.current;
                // If the video element doesn't have a loaded source or the source has changed since the
                // last time we played the video, make sure to force the video to load the most up-to-date sources
                videoElement.load();
                // Reset the next start time to the start of the video
                nextVideoStartTimeRef.current = playbackRangeStart || 0;
            }
        }
    }, [formattedVideoSources, isPlaying, playbackRangeStart]);
    var hasPausedOverlay = Boolean(pausedOverlay);
    var hasHoverOverlay = Boolean(hoverOverlay);
    // If we have a paused or hover overlay, the player should wait
    // for the overlay(s) to finish transitioning back in before we
    // pause the video
    var shouldWaitForOverlayTransitionBeforePausing = hasPausedOverlay || hasHoverOverlay;
    useEffect(function () {
        if (!hoverTargetElement)
            return undefined;
        var playbackStartTimeout = null;
        var pauseTimeout = null;
        var cancelTimeouts = function () {
            // Cancel any previously active pause or playback attempts
            window.clearTimeout(playbackStartTimeout);
            window.clearTimeout(pauseTimeout);
        };
        var attemptToPlayVideoOnHover = function () {
            cancelTimeouts();
            setIsHovering(true);
            // We only need to attempt to play if the video is currently paused
            if (isVideoElementPaused(videoRef.current)) {
                if (playbackStartDelay) {
                    playbackStartTimeout = window.setTimeout(function () { return attemptToPlayVideoRef.current(); }, playbackStartDelay);
                }
                else {
                    attemptToPlayVideoRef.current();
                }
            }
        };
        var attemptToPauseVideoOnHoverEnd = function () {
            cancelTimeouts();
            setIsHovering(false);
            if (
            // We only need to delay a pause attempt if the video is currently playing
            isVideoElementPlaying(videoRef.current) &&
                shouldWaitForOverlayTransitionBeforePausing) {
                pauseTimeout = window.setTimeout(function () { return attemptToPauseVideoRef.current(); }, overlayTransitionDuration);
            }
            else {
                attemptToPauseVideoRef.current();
            }
        };
        hoverTargetElement.addEventListener('hvp:hoverStart', attemptToPlayVideoOnHover);
        hoverTargetElement.addEventListener('hvp:hoverEnd', attemptToPauseVideoOnHoverEnd);
        return function () {
            hoverTargetElement.removeEventListener('hvp:hoverStart', attemptToPlayVideoOnHover);
            hoverTargetElement.removeEventListener('hvp:hoverEnd', attemptToPauseVideoOnHoverEnd);
            cancelTimeouts();
        };
    }, [
        hoverTargetElement,
        overlayTransitionDuration,
        playbackStartDelay,
        shouldWaitForOverlayTransitionBeforePausing,
    ]);
    useManageHoverEvents(hoverTargetElement, focused, disableDefaultEventHandling, onHoverStart, onHoverEnd);
    // We should attempt to play the video if the user is hovering over it or the `focused` override prop is enabled
    // const shouldPlayVideo = isHoveringOverVideo || focused;
    var hasLoadingOverlay = Boolean(loadingOverlay);
    // If the video's sources should be unloaded when it's paused and the video is not currently active, we can unload the video's sources.
    // We will remove the video's <source> tags in this render and then call video.load() in an effect to
    // fully unload the video
    var shouldUnloadVideo = unloadVideoOnPaused && !isHovering && !isPlaying;
    useEffect(function () {
        // If shouldUnloadVideo is true, this effect is being run after the video's
        // sources have been removed, so call load on the video to unload any sources it currently has loaded
        if (shouldUnloadVideo) {
            var videoElement = videoRef.current;
            videoElement.load();
        }
    }, [shouldUnloadVideo]);
    var shouldShowLoadingOverlay = isHovering && !isPlaying;
    // Show a paused overlay when the user isn't hovering or when the user is hovering
    // but the video is still loading
    var shouldShowPausedOverlay = !isHovering || (isHovering && !isPlaying);
    var isUsingPlaybackRange = playbackRangeStart !== null || playbackRangeEnd !== null;
    return (React.createElement("div", __assign({ "data-testid": "hover-video-player-container", ref: containerRef, style: __assign(__assign(__assign({}, containerSizingStyles[sizingMode]), { position: 'relative' }), style) }, spreadableProps),
        hasPausedOverlay ? (React.createElement("div", { style: __assign(__assign(__assign({}, pausedOverlayWrapperSizingStyles[sizingMode]), { zIndex: 1, opacity: shouldShowPausedOverlay ? 1 : 0, transition: "opacity ".concat(overlayTransitionDuration, "ms"), 
                // Disable pointer events on the paused overlay when it's hidden
                pointerEvents: shouldShowPausedOverlay ? 'auto' : 'none' }), pausedOverlayWrapperStyle), className: pausedOverlayWrapperClassName, "data-testid": "paused-overlay-wrapper" }, pausedOverlay)) : null,
        hasLoadingOverlay ? (React.createElement("div", { style: __assign(__assign(__assign({}, expandToFillContainerStyle), { zIndex: 2, opacity: shouldShowLoadingOverlay ? 1 : 0, transition: "opacity ".concat(overlayTransitionDuration, "ms ").concat(shouldShowLoadingOverlay ? loadingStateTimeout : 0, "ms"), 
                // Disable pointer events on the loading overlay when it's hidden
                pointerEvents: shouldShowLoadingOverlay ? 'auto' : 'none' }), loadingOverlayWrapperStyle), className: loadingOverlayWrapperClassName, "data-testid": "loading-overlay-wrapper" }, loadingOverlay)) : null,
        hasHoverOverlay ? (React.createElement("div", { style: __assign(__assign(__assign({}, expandToFillContainerStyle), { zIndex: 3, 
                // Show the hover overlay when the player is hovered/playing
                opacity: isHovering ? 1 : 0, transition: "opacity ".concat(overlayTransitionDuration, "ms"), 
                // Disable pointer events on the hover overlay when it's hidden
                pointerEvents: isHovering ? 'auto' : 'none' }), hoverOverlayWrapperStyle), className: hoverOverlayWrapperClassName, "data-testid": "hover-overlay-wrapper" }, hoverOverlay)) : null,
        React.createElement("video", { 
            // If a playback range is set, the loop attribute will not work correctly so there's no point in setting it here;
            // in that case, we will manually implement this behavior
            loop: isUsingPlaybackRange ? false : loop, playsInline: true, preload: preload, crossOrigin: crossOrigin, ref: videoRef, style: __assign(__assign(__assign({}, videoSizingStyles[sizingMode]), { objectFit: 'cover' }), videoStyle), controls: controls, controlsList: controlsList, className: videoClassName, id: videoId, "data-testid": "video-element", onPlaying: function () {
                setIsPlaying(true);
            }, onTimeUpdate: 
            // If there's a playback range set, the traditional `loop` video prop won't work correctly so
            // we'll need watch the video's time as it plays and manually keep it within the bounds of the range
            isUsingPlaybackRange
                ? function () {
                    var videoElement = videoRef.current;
                    var maxVideoTime = playbackRangeEnd || videoElement.duration;
                    var minVideoTime = playbackRangeStart || 0;
                    var currentTime = videoElement.currentTime;
                    if (loop && currentTime >= maxVideoTime) {
                        // If the video should loop and is >= the max video time,
                        // loop it back around to the start
                        var startTime = playbackRangeStart || 0;
                        videoElement.currentTime = startTime;
                        // If the video is paused but the user is still hovering,
                        // meaning it should continue to play, call play() to keep it going
                        if (isHovering && isVideoElementPaused(videoElement)) {
                            videoElement.play();
                        }
                    }
                    else if (currentTime > maxVideoTime) {
                        // If the video shouldn't loop but we've exceeded the max video time,
                        // clamp it to the max time and pause it
                        videoElement.pause();
                        videoElement.currentTime = maxVideoTime;
                    }
                    else if (currentTime < minVideoTime) {
                        // If the video's time somehow ended up before the min video time,
                        // clamp it to the min time
                        videoElement.currentTime = minVideoTime;
                    }
                }
                : null },
            !shouldUnloadVideo &&
                // Only render sources for the video if it is not unloaded
                formattedVideoSources.map(function (_a) {
                    var src = _a.src, type = _a.type;
                    return (React.createElement("source", { key: src, src: src, type: type }));
                }),
            formattedVideoCaptions.map(function (_a) {
                var src = _a.src, srcLang = _a.srcLang, label = _a.label, kind = _a.kind, isDefault = _a.default;
                return (React.createElement("track", { key: src, kind: kind, src: src, srcLang: srcLang, label: label, default: isDefault }));
            }))));
}

export { HoverVideoPlayer as default };
//# sourceMappingURL=index.esm.js.map
